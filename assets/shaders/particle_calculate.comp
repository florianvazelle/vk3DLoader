#version 450

// struct Particle
// {
// 	vec4 pos;
// 	vec4 vel;
// };

// MPM struct particle
struct Particle {
	vec2 pos; // position "vec2" because this mpm example works in 2D
	vec2 vel; // velocity 
	mat2 C; // affine momentum matrix
	float mass;
	float volume_0; // initial volume
};

// MPM struct cell
struct Cell {
	vec2 vel; // velocity
	float mass;
};

// Binding 0 : Particle storage buffer
layout(std140, binding = 0) buffer Pos 
{
   Particle particles[]; //ps
};

// ************************************* MPM *************************************
// initiate cells array in the shader

// Binding 1 : Grid storage buffer
layout(std140, binding = 2) buffer cells 
{
   Cell grid[]; //ps
};

// Binding 2 : Deformation gradient storage buffer
// deformation gradient. stored as a separate array to use same rendering code for all demos, but feel free to store this field in the particle struct instead
layout(std140, binding = 3) buffer deformationGradient 
{
   mat2 Fs[]; //ps
};

// vec4 temp_positions[]; // Only used in start() -> c++  float2 -> vec4 for 3D
// *******************************************************************************

layout (local_size_x = 256) in;

layout (binding = 1) uniform UBO 
{
	float deltaT;
	int particleCount;
} ubo;

// MPM Constants
// ******************************************************************************************
const int GRID_RESOLUTION = 64;
int num_cells = int(GRID_RESOLUTION * GRID_RESOLUTION);

// batch size for the job system. just determined experimentally
// layout (constant_id = 5) const float DIVISION = 16; we don't know how many threads will works

// simulation parameters
const float dt = 0.1f; // timestep
const float gravity = -0.3f;

// Lamé parameters for stress-strain relationship
const float ELASTIC_LAMBDA = 10.0f;
const float ELASTIC_MU = 20.0f;
// ******************************************************************************************

void job_ClearGrid() {
	uint index = gl_GlobalInvocationID.x;
	// if we create more threads than cells
	if (index >= num_cells)
		return;

	Cell cell = grid[index];

	// reset grid scratch-pad entirely
	cell.mass = 0.0;
	cell.vel = vec2(0.0);

	grid[index] = cell;

	// wait all the threads to finish
	memoryBarrierShared();
	barrier();
}

void job_P2G() { // P2G, first round
	uint index = gl_GlobalInvocationID.x;
	// Only on one thread
	if (index != 0)
		return;
	
	vec2 weights[3]; // redefined

	for (int i = 0; i < ubo.particleCount; ++i) {
		Particle p = particles[i];
		
		mat2 stress = mat2(0.0);

		// deformation gradient
		mat2 F = Fs[index];

		float J = determinant(F);

		// MPM course, page 46
		float volume = p.volume_0 * J;

		// useful matrices for Neo-Hookean model
		mat2 F_T = transpose(F);
		mat2 F_inv_T = inverse(F_T);
		mat2 F_minus_F_inv_T = F - F_inv_T;

		// MPM course equation 48
		mat2 P_term_0 = ELASTIC_MU * (F_minus_F_inv_T);
		mat2 P_term_1 = ELASTIC_LAMBDA * log(J) * F_inv_T;
		mat2 P = P_term_0 + P_term_1;

		// cauchy_stress = (1 / det(F)) * P * F_T
		// equation 38, MPM course
		stress = (1.0f / J) * (P * F_T);

		// (M_p)^-1 = 4, see APIC paper and MPM course page 42
		// this term is used in MLS-MPM paper eq. 16. with quadratic weights, Mp = (1/4) * (delta_x)^2.
		// in this simulation, delta_x = 1, because i scale the rendering of the domain rather than the domain itself.
		// we multiply by dt as part of the process of fusing the momentum and force update for MLS-MPM
		mat2 eq_16_term_0 = -volume * 4 * stress * dt;

		// quadratic interpolation weights
		vec2 cell_idx = floor(p.pos); // uvec2 -> unsigned
		vec2 cell_diff = (p.pos - cell_idx) - 0.5;
		weights[0] = 0.5 * ((vec2(0.5, 0.5) - cell_diff) * (vec2(0.5, 0.5) - cell_diff));
		weights[1] = 0.75 - (cell_diff * cell_diff);
		weights[2] = 0.5 * ((vec2(0.5, 0.5) + cell_diff) * (vec2(0.5, 0.5) + cell_diff));

		// for all surrounding 9 cells
		for (uint gx = 0; gx < 3; ++gx) {
			for (uint gy = 0; gy < 3; ++gy) {
				float weight = weights[gx].x * weights[gy].y;
				
				uvec2 cell_x = uvec2(cell_idx.x + gx - 1, cell_idx.y + gy - 1); // uint2
				vec2 cell_dist = (vec2(cell_x) - p.pos) + 0.5f; // cast uvec2 into vec2
				vec2 Q = p.C * cell_dist;

				// scatter mass and momentum to the grid
				int cell_index = int(cell_x.x) * GRID_RESOLUTION + int(cell_x.y);
				Cell cell = grid[cell_index];

				// MPM course, equation 172
				float weighted_mass = weight * p.mass;
				cell.mass += weighted_mass;

				// APIC P2G momentum contribution
				cell.vel += weighted_mass * (p.vel + Q);

				// fused force/momentum update from MLS-MPM
				// see MLS-MPM paper, equation listed after eqn. 28
				vec2 momentum = (eq_16_term_0 * weight) * cell_dist;
				cell.vel += momentum;

				// total update on cell.v is now:
				// weight * (dt * M^-1 * p.volume * p.stress + p.mass * p.C)
				// this is the fused momentum + force from MLS-MPM. however, instead of our stress being derived from the energy density,
				// i use the weak form with cauchy stress. converted:
				// p.volume_0 * (dΨ/dF)(Fp)*(Fp_transposed)
				// is equal to p.volume * σ

				// note: currently "cell.v" refers to MOMENTUM, not velocity!
				// this gets converted in the UpdateGrid step below.

				grid[cell_index] = cell;
			}
		}
	}
}

void update_grid () {
	uint index = gl_GlobalInvocationID.x;
	// if we create more threads than cells
	if (index >= num_cells)
		return;
	
	Cell cell = grid[index];

	if (cell.mass > 0) {
		// convert momentum to velocity, apply gravity
		cell.vel /= cell.mass;
		cell.vel += dt * vec2(0.0, gravity);

		// 'slip' boundary conditions
		int x = int(index) / GRID_RESOLUTION;
		int y = int(index) % GRID_RESOLUTION;
		if (x < 2 || x > GRID_RESOLUTION - 3) { cell.vel.x = 0; }
		if (y < 2 || y > GRID_RESOLUTION - 3) { cell.vel.y = 0; }

		grid[index] = cell;
	}

	// wait all the threads to finish
	memoryBarrierShared();
	barrier();
}

void job_G2P () {
	uint index = gl_GlobalInvocationID.x;
	// if we create more threads than cells
	if (index >= ubo.particleCount)
		return;

	Particle p = particles[index];

	// reset particle velocity. we calculate it from scratch each step using the grid
	p.vel = vec2(0.0);

	
	// quadratic interpolation weights
	vec2 cell_idx = floor(p.pos); // uvec2 -> unsigned
	vec2 cell_diff = (p.pos - cell_idx) - 0.5f;
	vec2 weights[3] = {
		0.5 * ((vec2(0.5, 0.5) - cell_diff) * (vec2(0.5, 0.5) - cell_diff)),
		0.75 - (cell_diff * cell_diff), 
		0.5 * ((vec2(0.5, 0.5) + cell_diff) * (vec2(0.5, 0.5) + cell_diff))
	};

	// constructing affine per-particle momentum matrix from APIC / MLS-MPM.
	// see APIC paper (https://web.archive.org/web/20190427165435/https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf), page 6
	// below equation 11 for clarification. this is calculating C = B * (D^-1) for APIC equation 8,
	// where B is calculated in the inner loop at (D^-1) = 4 is a constant when using quadratic interpolation functions
	mat2 B = mat2(0.0);
	for (uint gx = 0; gx < 3; ++gx) {
		for (uint gy = 0; gy < 3; ++gy) {
			float weight = weights[gx].x * weights[gy].y;

			uvec2 cell_x = uvec2(cell_idx.x + gx - 1, cell_idx.y + gy - 1);
			int cell_index = int(cell_x.x) * GRID_RESOLUTION + int(cell_x.y);
			
			vec2 dist = (cell_x - p.pos) + 0.5;
			vec2 weighted_velocity = grid[cell_index].vel * weight;

			// APIC paper equation 10, constructing inner term for B
			mat2 term = mat2(weighted_velocity * dist.x, weighted_velocity * dist.y);

			B += term;

			p.vel += weighted_velocity;
		}
	}
	p.C = B * 4;

	// advect particles
	p.pos += p.vel * dt;

	// safety clamp to ensure particles don't exit simulation domain
	p.pos = clamp(p.pos, 1, GRID_RESOLUTION - 2);

	mat2 Fp_new = mat2(1, 0,
					   0, 1);
	Fp_new += dt * p.C;
	Fs[index] = Fp_new * Fs[index];
	particles[index] = p;
}

void main() {// Simulate
	// *** MPM loop ***

	// clear the grid of cells
	job_ClearGrid();
	// wait until all jobs finished

	// Particles to grid
	job_P2G();

	// Update grid
	update_grid();

	// grid to Particle
	job_G2P();
}